"""
Tools for Energy Model Optimization and Analysis (Temoa): 
An open source framework for energy systems optimization modeling

Copyright (C) 2015,  NC State University

This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

A complete copy of the GNU General Public License v2 (GPLv2) is available 
in LICENSE.txt.  Users uncompressing this from an archive may not have 
received this license file.  If not, see <http://www.gnu.org/licenses/>.

This file aims at enabling the myopic solve using a sqlite database as 
input. The algorithm works by: i) reading the time periods from the 
original sqlite input database ii) iterating over individual periods and 
creating a database with the previous buildups as existing capacity, 
iii) and finally running each periods at a time and writing the results 
to the original database. 
"""

import sqlite3
import pandas as pd	
from shutil import copyfile
import os

def myopic_db_generator_solver ( self ):

	db_path_org = self.options.output
	con_org = sqlite3.connect(db_path_org)
	cur_org = con_org.cursor()			
	table_list = cur_org.execute("SELECT name FROM sqlite_master WHERE type='table' AND name NOT LIKE 'Output%'").fetchall()
	time_periods = cur_org.execute("SELECT t_periods FROM time_periods WHERE flag='f'").fetchall()
	loc1 = max(loc for loc, val in enumerate(self.options.output) if val == '/')
	loc2 = max(loc for loc, val in enumerate(self.options.output) if val == '.')
	db_name = self.options.output[loc1+1:loc2]
	copyfile(db_path_org, self.options.path_to_db_io+"/"+db_name+"_blank"+self.options.output[loc2:])
	# group 1 consists of non output tables in which "periods" is a column name 
	tables_group1 = ['CostFixed','CostVariable','Demand','EmissionLimit','MaxActivity','MaxCapacity', \
					 'MinActivity','MinCapacity','TechInputSplit','TechOutputSplit','CapacityCredit','MinGenGroupTarget']
	# group 2 consists of non output tables in which "vintage" is a column name except for CostFixed and CostVariable (taken care of above)
	tables_group2 = ['CapacityFactorProcess','CostInvest','DiscountRate', \
					 'Efficiency','EmissionActivity','ExistingCapacity','LifetimeProcess']	
	for i in range(0,len(time_periods)-1):
		print ('Preparing the database for the period '+str(time_periods[i][0]))
		new_db = self.options.path_to_db_io+"/"+db_name+"_myopic_"+str(time_periods[i][0])+self.options.output[loc2:]
		copyfile(self.options.path_to_db_io+"/"+db_name+"_blank"+self.options.output[loc2:], new_db)
		con = sqlite3.connect(new_db)
		cur = con.cursor()
		table_list.sort()

    	# ---------------------------------------------------------------
    	# Start modifying the Efficiency table
    	# ---------------------------------------------------------------
		cur.execute("DELETE FROM Efficiency WHERE vintage > "+str(time_periods[i][0])+";")
		
		cur.execute("UPDATE Efficiency SET tech = TRIM(tech);") #trim spaces. Need to trim carriage return
		
		# Delete row from Efficiency if (t,v) retires at the begining of current period (which is time_periods[i][0])
		cur.execute("DELETE FROM Efficiency WHERE tech IN (SELECT tech FROM LifetimeProcess WHERE \
					 LifetimeProcess.life_process+LifetimeProcess.vintage<="+str(time_periods[i][0])+") \
					 AND vintage IN (SELECT vintage FROM LifetimeProcess WHERE LifetimeProcess.life_process+\
					 LifetimeProcess.vintage<="+str(time_periods[i][0])+");")
		
		# Delete row from Efficiency if (t,v) retires at the begining of current period (which is time_periods[i][0])
		cur.execute("DELETE FROM Efficiency WHERE tech IN (SELECT tech FROM LifetimeTech WHERE \
					 LifetimeTech.life+Efficiency.vintage<="+str(time_periods[i][0])+") AND \
					 vintage NOT IN (SELECT vintage FROM LifetimeProcess WHERE LifetimeProcess.tech\
					 =Efficiency.tech);")
		
		# If row is not deleted via the last two DELETE commands, it might still be invalid for period
		#  time_periods[i][0] since they can have model default lifetime of 40 years. 
		cur.execute("DELETE FROM Efficiency WHERE tech IN (SELECT tech FROM Efficiency WHERE \
					40+Efficiency.vintage<="+str(time_periods[i][0])+") AND \
					tech NOT IN (SELECT tech FROM LifetimeTech) AND \
					vintage NOT IN (SELECT vintage FROM LifetimeProcess WHERE LifetimeProcess.tech=Efficiency.tech);")
		
		# Above commits could break commodity flows defined in the Efficiecny table. We need to delete rows with
		# output commodities that are not generated by any other process. The exception is demand commodities (flag='d')
		# This is performed twice to delete the recods that are not deleted in the first attempt.
		cur.execute("DELETE FROM Efficiency WHERE output_comm NOT IN (SELECT input_comm FROM Efficiency) \
					 AND output_comm NOT IN (SELECT comm_name FROM commodities WHERE flag='d');")
		
		cur.execute("DELETE FROM Efficiency WHERE output_comm NOT IN (SELECT input_comm FROM Efficiency) \
					 AND output_comm NOT IN (SELECT comm_name FROM commodities WHERE flag='d');")
		
    	# ---------------------------------------------------------------
    	# Sufficient changes were made on the Efficiency table. 
    	# Start modifying other tables.
    	# ---------------------------------------------------------------
		for table in tables_group1:
			cur.execute("DELETE FROM "+table +" WHERE periods != "+str(time_periods[i][0])+";")


		for table in tables_group2:
			if table == 'CostInvest' or table == 'DiscountRate':
				cur.execute("UPDATE "+table+" SET tech = TRIM(tech);")
				cur.execute("DELETE FROM "+table +" WHERE vintage > "+str(time_periods[i][0])+";")
			else:
				cur.execute("DELETE FROM "+table +" WHERE vintage > "+str(time_periods[i][0])+";")

		# time_periods is the only non output table with "t_periods" as a column
		cur.execute("DELETE FROM time_periods WHERE t_periods > "+str(time_periods[i][0])+";")

		
    	# ---------------------------------------------------------------
    	# Add the buildups from the previous period to the ExistingCapacity
    	# table. The data is stored in the Output_V_Capacity of the con_org
    	# ---------------------------------------------------------------


		if i!=0:
			df_new_ExistingCapacity = pd.read_sql_query("SELECT regions, tech, vintage, capacity FROM Output_V_Capacity \
														 WHERE scenario="+"'"+str(self.options.scenario)+"';", con_org) 
			df_new_ExistingCapacity.columns = ['regions','tech','vintage','exist_cap']
			df_new_ExistingCapacity.to_sql('ExistingCapacity',con, if_exists='append', index=False)
	
			#Create a copy of the first time period vintages for the current vintage 
			#to prevent infeasibility (if it is not an 'existing' vintage in the 
			#original database and if it doesn't already have a current vintage). One example: 
			# dummy technologies that have only the first time period vintage (p0)					
			cur.execute("INSERT INTO Efficiency \
						 SELECT DISTINCT regions,input_comm,tech,"+str(time_periods[i][0])+ \
						 ",output_comm,efficiency,eff_notes FROM Efficiency WHERE tech NOT IN (SELECT tech \
						 FROM Efficiency WHERE vintage<"+str(time_periods[0][0])+") AND tech NOT IN (SELECT \
						 tech FROM Efficiency WHERE vintage="+str(time_periods[i][0])+");")

			# delete (t,v) from efficiecny table if it doesn't appear in the ExistingCapacity (v is an existing vintage).
			# (note that the model throws a warning if (t,v) is an existing vintage but it doesn't appear in ExistingCapacity)
			cur.execute("DELETE FROM Efficiency \
						 WHERE vintage < "+str(time_periods[i][0])+" AND vintage NOT IN (SELECT \
						 vintage FROM ExistingCapacity WHERE Efficiency.tech=ExistingCapacity.tech);")
		

    	# ---------------------------------------------------------------
    	# The Efficiency table is now ready. Continue modifying other tables.
    	# ---------------------------------------------------------------
		for table in table_list:
			if table[0] == 'Efficiency': continue 
			try:
				cur.execute("UPDATE "+str(table[0])+" SET tech = TRIM(tech, CHAR(37,10));")
				# If t doesn't exist in Efficiency table after the deletions made above, 
				# it is deleted from other tables.
				cur.execute("DELETE FROM "+str(table[0])+" WHERE tech NOT IN (SELECT tech FROM Efficiency);")
				cursor = con.execute("SELECT * FROM "+str(table[0]))
				names = list(map(lambda x: x[0], cursor.description))
				if 'vintage' in names:				
					#in line 308, a copy of (t,v=p0) was added to the Efficiecny table for certain rows. What if (t,v=p0)
					# had a cost or emissions? In a similar way, we need to add a copy of (t,v=p0) to other tables (except
					# for Efficiency and ExistingCapacity) for the current period if the same conditions are met. 
					if table[0]!='ExistingCapacity':
						names = [str(time_periods[i][0]) if x=='vintage' else x for x in names]
						cur.execute("INSERT INTO "+table[0]+" SELECT DISTINCT "+",".join(names)+\
									 " FROM "+table[0]+" WHERE tech NOT IN (SELECT tech FROM "+table[0]+\
									 " WHERE vintage<"+str(time_periods[0][0])+") AND tech NOT IN (SELECT tech FROM "+\
									 table[0]+" WHERE vintage="+str(time_periods[i][0])+");"
									 )
					# For these two table we only want current vintages. 
					if table[0] == 'CostInvest' or table[0] == 'DiscountRate':
						cur.execute("DELETE FROM "+str(table[0])+" WHERE vintage!="+str(time_periods[i][0])+";")
					# If (t,v) is not found in the Efficiecny table, deelte it from all the other tables
					cur.execute("DELETE FROM "+str(table[0])+" WHERE tech IN (SELECT tech FROM Efficiency) AND vintage \
								 NOT IN (SELECT vintage FROM Efficiency WHERE Efficiency.tech="+str(table[0])+".tech);")			
			except:
				pass
		
		cur.execute("UPDATE commodities SET comm_name = TRIM(comm_name, CHAR(37,10))")
		# delete unused commodities otherwise the model throws an error

		cur.execute("DELETE FROM commodities WHERE flag!='e' AND comm_name NOT IN (SELECT input_comm from Efficiency UNION SELECT output_comm from Efficiency);")
		cur.execute("INSERT INTO `time_periods` (t_periods,flag) VALUES ("+str(time_periods[i+1][0])+",'f');")
		cur.execute("UPDATE `time_periods` SET flag='e' WHERE t_periods < "+str(time_periods[i][0]))
		con.commit()
		con.close()

		# looks like the VACUUM command does not work well
		# in python 3 if embeded in line 180. To avoid potential
		# errors, the database is closed and re-opened.
		con = sqlite3.connect(new_db, isolation_level=None)
		cur = con.cursor()
		cur.execute("VACUUM")
		con.commit()
		con.close()
    	# ---------------------------------------------------------------
    	# the database is ready. It is run via a temporary config file in 
    	# a perfect foresight fashion.
    	# ---------------------------------------------------------------
		new_config = os.getcwd()+"/temoa_model/config_sample_myopic_"+str(time_periods[i][0])
		ifile = open(os.getcwd()+"/temoa_model/config_sample")
		ofile = open(new_config,'w')
		for line in ifile:
			new_line = line.replace("--input=data_files/"+db_name, "--input=data_files/"+db_name+"_myopic_"+str(time_periods[i][0]))
			# the temporary config file is created from the original config file. Since for individual periods we are 
			# going to have a standard run, '--myopic' needs to be commented out. 
			new_line = new_line.replace("--myopic","#--myopic")
			ofile.write(new_line)
		ifile.close()
		ofile.close()
		os.system("python temoa_model/ --config=temoa_model/config_sample_myopic_"+str(time_periods[i][0]))
		# delete the temporary config file
		os.system("rm -rf temoa_model/config_sample_myopic_"+str(time_periods[i][0]))
	
	os.system("rm -rf "+self.options.path_to_db_io+"/"+db_name+"_blank"+self.options.output[loc2:])	
